# Part B: Design

## Data Structures
- **Product:** Represents an item with name, SKU, price, and quantity.
- **Location:** Represents a warehouse cell with capacity and inventory.
- **Warehouse:** Manages a grid of locations and product catalog.

## OOP Implementation in Classes
- **Product:** Encapsulates product data and provides update methods.
- **Location:** Manages inventory for a specific cell, with methods for adding/removing products.
- **Warehouse:** Coordinates locations and products, handles storage/retrieval logic.

## Pseudocode for Three Classes

### Product
```
class Product:
    - name
    - sku
    - price
    - quantity
    + update_price(new_price)
    + update_quantity(delta)
```

### Location
```
class Location:
    - row
    - col
    - capacity
    - inventory (dict)
    + add_product(product, qty)
    + remove_product(sku, qty)
    + get_available_capacity()
```

### Warehouse
```
class Warehouse:
    - rows
    - cols
    - grid (2D list of Location)
    - products (dict)
    + add_product(product)
    + store_product(sku, qty, row, col)
    + retrieve_product(sku, qty, row, col)
    + find_product(sku)
```

### Mainline Design
```
main():
    user = input("Enter username")
    app = WarehouseApp(root, user)
    root.mainloop()
```

## Version Control Planning
- Use Git for version control.
- Branches: `main`, `dev`, `feature/*`
- Commit messages follow the format: `<type>: <description>`

## Exception Handling (Pseudocode)
```
try:
    price = float(input("Enter price: "))
except ValueError:
    print("Invalid price entered.")
```

## Algorithm Design and Testing

### Validation
- Check for valid input types and ranges (e.g., positive quantities, unique SKUs).

### Testing Plan
- Unit tests for each class and method.
- Integration tests for workflows (add, store, retrieve).
- Manual GUI testing.

### Writing for Maintenance
- Use clear comments and docstrings.
- Modular code structure.
- Consistent naming conventions.
