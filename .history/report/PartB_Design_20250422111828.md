# Part B: Design

## Data Structures and OOP Implementation
### Product Class
- **Attributes:** name (str), sku (str), price (float), quantity (int)
- **Methods:** update_price(), update_quantity(), __str__(), validation methods
- **OOP:** Encapsulates product data, supports future inheritance (e.g., PerishableProduct)

### Location Class
- **Attributes:** row (int), col (int), capacity (int), inventory (dict)
- **Methods:** add_product(), remove_product(), get_available_capacity(), get_location_code()
- **OOP:** Encapsulates location logic, supports polymorphic inventory management

### Warehouse Class
- **Attributes:** rows (int), cols (int), grid (2D list of Location), products (dict)
- **Methods:** add_product(), store_product(), retrieve_product(), find_product(), validate_quantities(), load_data(), save_data()
- **OOP:** Coordinates all operations, abstracts storage logic, supports extension (e.g., SmartWarehouse)

## Pseudocode for Three Classes and Mainline

### Product
```
Class Product:
    Attributes:
        name: String
        sku: String
        price: Float
        quantity: Integer
    Methods:
        update_price(new_price: Float)
        update_quantity(delta: Integer)
        validate()
        __str__()
```

### Location
```
Class Location:
    Attributes:
        row: Integer
        col: Integer
        capacity: Integer
        inventory: Dictionary<String, Integer>
    Methods:
        add_product(product: Product, qty: Integer)
        remove_product(sku: String, qty: Integer)
        get_available_capacity() -> Integer
        get_location_code() -> String
```

### Warehouse
```
Class Warehouse:
    Attributes:
        rows: Integer
        cols: Integer
        grid: 2D List<Location>
        products: Dictionary<String, Product>
    Methods:
        add_product(product: Product)
        store_product(sku: String, qty: Integer, row: Integer, col: Integer)
        retrieve_product(sku: String, qty: Integer, row: Integer, col: Integer)
        find_product(sku: String) -> List<(row, col)>
        validate_quantities() -> List<String>
        load_data()
        save_data()
```

### Mainline
```
Function main():
    user = input("Enter username: ")
    warehouse = Warehouse(rows=5, cols=5)
    warehouse.load_data()
    cli = CLIInterface(user, warehouse)
    cli.run()
```

## Version Control Planning
- **Tool:** Git
- **Branching:** main (stable), dev (integration), feature/* (per feature)
- **Commits:** Descriptive messages, atomic changes, referencing issues/tasks
- **Tags:** For major milestones (v1.0, v2.0, etc.)
- **Backup:** Regular pushes to remote repository (e.g., GitHub)

## Exception Handling and Validation (Pseudocode)
```
try:
    price = float(input("Enter price: "))
    if price < 0:
        raise ValueError("Price must be non-negative")
except ValueError as e:
    print(f"Input error: {e}")
```

## Algorithm Design and Testing
### Validation
- All user inputs are validated for type, range, and business rules (e.g., unique SKU, positive quantities).
- Data loaded from files is checked for integrity and consistency.

### Testing Plan
- **Unit Tests:** For all class methods (add, store, retrieve, validation)
- **Integration Tests:** For workflows (add product, store/retrieve, search)
- **System Tests:** Using provided test data (Appendix 1)
- **Manual Testing:** CLI walkthroughs, edge cases, error handling

### Writing for Maintenance
- **Documentation:** Docstrings for all classes/methods, README with usage and architecture
- **Code Style:** PEP8 compliance, meaningful names, modular structure
- **Extensibility:** OOP design supports new features with minimal changes
- **Comments:** Explain logic, design decisions, and error handling
