# Part B: Design

## Data Structures and OOP Implementation

When I started designing the system, I knew I wanted to keep things modular and easy to understand. I broke the project into three main classes: Product, Location, and Warehouse. Here’s how I approached each one:

### Product Class
- **Attributes:** name, sku, price, quantity
- **Methods:** update_price, update_quantity, __str__, and validation methods
- **OOP:** This class is all about encapsulating product data. I made sure it only handles product-specific logic, so if I want to add more product types later, I can just extend this class.

### Location Class
- **Attributes:** row, col, capacity, inventory (dict of SKU to quantity)
- **Methods:** add_product, remove_product, get_available_capacity, get_location_code
- **OOP:** Each location manages its own inventory. This keeps the logic for storage separate from the rest of the system, and makes it easy to check or update what’s in a specific spot.

### Warehouse Class
- **Attributes:** rows, cols, grid (2D list of Location), products (dict of SKU to Product)
- **Methods:** add_product, store_product, retrieve_product, find_product, validate_quantities, load_data, save_data
- **OOP:** The Warehouse class ties everything together. It manages the grid, keeps track of all products, and handles the main operations. If I want to add more advanced features later, I can do it here without messing up the rest of the code.

## Pseudocode for Three Classes and Mainline

### Product
```
class Product:
    def __init__(self, name, sku, price, quantity):
        ...
    def update_price(self, new_price):
        ...
    def update_quantity(self, delta):
        ...
    def __str__(self):
        ...
```

### Location
```
class Location:
    def __init__(self, row, col, capacity):
        ...
    def add_product(self, product, qty):
        ...
    def remove_product(self, sku, qty):
        ...
    def get_available_capacity(self):
        ...
    def get_location_code(self):
        ...
```

### Warehouse
```
class Warehouse:
    def __init__(self, rows, cols):
        ...
    def add_product(self, product):
        ...
    def store_product(self, sku, qty, row, col):
        ...
    def retrieve_product(self, sku, qty, row, col):
        ...
    def find_product(self, sku):
        ...
    def validate_quantities(self):
        ...
    def load_data(self):
        ...
    def save_data(self):
        ...
```

### Mainline
```
def main():
    user = input("Enter username: ")
    warehouse = Warehouse(rows=5, cols=8)
    warehouse.load_data()
    # Choose GUI or CLI here
    # ...
```

## Version Control Planning

I used Git for version control. I kept my main branch stable, and did all my new features and bug fixes in separate branches. I tried to write clear commit messages so I could track what I changed and why. I also pushed to GitHub regularly so I wouldn’t lose my work.

## Exception Handling and Validation (Pseudocode)

```
try:
    price = float(input("Enter price: "))
    if price < 0:
        raise ValueError("Price must be non-negative")
except ValueError as e:
    print(f"Input error: {e}")
```

## Algorithm Design and Testing

### Validation
- I made sure to check all user inputs for type, range, and business rules (like unique SKUs and positive quantities).
- When loading data from files, I checked for missing or invalid entries.

### Testing Plan
- I wrote unit tests for the main class methods (add, store, retrieve, validation).
- I tested workflows like adding a product, storing it, and retrieving it, both in the GUI and CLI.
- I used the provided test data to make sure everything worked as expected.
- I also did manual testing, trying out edge cases and intentionally entering bad data to see if the system handled it.

### Writing for Maintenance
- I added docstrings to all my classes and methods, and wrote a README with instructions.
- I followed PEP8 style and used meaningful names for everything.
- The code is modular, so if I want to add new features or fix bugs later, I can do it without breaking the rest of the system.
- I left comments explaining tricky parts or important design decisions.
