# Part B: Design

## Data Structures and OOP Implementation

When I started designing the system, I knew I wanted to keep things modular and easy to understand. I broke the project into three main classes: Product, Location, and Warehouse. Here’s how I approached each one:

### Product Class
- **Attributes:** name, sku, price, quantity
- **Methods:** update_price, update_quantity, __str__, and validation methods
- **OOP:** This class is all about encapsulating product data. I made sure it only handles product-specific logic, so if I want to add more product types later, I can just extend this class.

### Location Class
- **Attributes:** row, col, capacity, inventory (dict of SKU to quantity)
- **Methods:** add_product, remove_product, get_available_capacity, get_location_code
- **OOP:** Each location manages its own inventory. This keeps the logic for storage separate from the rest of the system, and makes it easy to check or update what’s in a specific spot.

### Warehouse Class
- **Attributes:** rows, cols, grid (2D list of Location), products (dict of SKU to Product)
- **Methods:** add_product, store_product, retrieve_product, find_product, validate_quantities, load_data, save_data
- **OOP:** The Warehouse class ties everything together. It manages the grid, keeps track of all products, and handles the main operations. If I want to add more advanced features later, I can do it here without messing up the rest of the code.

## Pseudocode for Three Classes and Mainline

# Pseudocode for Three Classes and Mainline

### Product
```python
class Product:
    def __init__(self, name, sku, price, quantity):
        # Validate input parameters
        if not isinstance(name, str) or len(name) == 0:
            raise ValueError("Name must be a non-empty string")
        if not isinstance(sku, str) or len(sku) == 0:
            raise ValueError("SKU must be a non-empty string")
        if not isinstance(price, (int, float)) or price < 0:
            raise ValueError("Price must be a non-negative number")
        if not isinstance(quantity, int) or quantity < 0:
            raise ValueError("Quantity must be a non-negative integer")
            
        # Set attributes
        self.name = name
        self.sku = sku
        self.price = price
        self.quantity = quantity
    
    def update_price(self, new_price):
        # Validate new price
        if not isinstance(new_price, (int, float)) or new_price < 0:
            raise ValueError("New price must be a non-negative number")
        
        # Update the price
        self.price = new_price
        return True
    
    def update_quantity(self, delta):
        # Calculate new quantity
        new_quantity = self.quantity + delta
        
        # Validate new quantity
        if new_quantity < 0:
            raise ValueError("Cannot reduce quantity below zero")
        
        # Update the quantity
        self.quantity = new_quantity
        return True
    
    def __str__(self):
        # Return a string representation of the product
        return f"Product: {self.name}, SKU: {self.sku}, Price: ${self.price:.2f}, Quantity: {self.quantity}"
```

### Location
```python
class Location:
    def __init__(self, row, col, capacity):
        # Validate input parameters
        if not isinstance(row, int) or row < 0:
            raise ValueError("Row must be a non-negative integer")
        if not isinstance(col, int) or col < 0:
            raise ValueError("Column must be a non-negative integer")
        if not isinstance(capacity, int) or capacity <= 0:
            raise ValueError("Capacity must be a positive integer")
        
        # Set attributes
        self.row = row
        self.col = col
        self.capacity = capacity
        self.inventory = {}  # Dictionary mapping SKU to quantity
    
    def add_product(self, sku, qty):
        # Validate input parameters
        if not isinstance(sku, str) or len(sku) == 0:
            raise ValueError("SKU must be a non-empty string")
        if not isinstance(qty, int) or qty <= 0:
            raise ValueError("Quantity must be a positive integer")
        
        # Check if there's enough space
        current_usage = sum(self.inventory.values())
        if current_usage + qty > self.capacity:
            raise ValueError("Not enough capacity at this location")
        
        # Add product to inventory or update quantity
        if sku in self.inventory:
            self.inventory[sku] += qty
        else:
            self.inventory[sku] = qty
        
        return True
    
    def remove_product(self, sku, qty):
        # Validate input parameters
        if not isinstance(sku, str) or len(sku) == 0:
            raise ValueError("SKU must be a non-empty string")
        if not isinstance(qty, int) or qty <= 0:
            raise ValueError("Quantity must be a positive integer")
        
        # Check if product exists in this location
        if sku not in self.inventory:
            raise ValueError(f"Product with SKU {sku} not found at this location")
        
        # Check if there's enough quantity to remove
        if self.inventory[sku] < qty:
            raise ValueError(f"Not enough quantity available (requested: {qty}, available: {self.inventory[sku]})")
        
        # Remove product or update quantity
        self.inventory[sku] -= qty
        if self.inventory[sku] == 0:
            del self.inventory[sku]
        
        return True
    
    def get_available_capacity(self):
        # Calculate and return available capacity
        current_usage = sum(self.inventory.values())
        return self.capacity - current_usage
    
    def get_location_code(self):
        # Generate a location code like "A1", "B2", etc.
        row_letter = chr(65 + self.row)  # Convert to A, B, C, etc.
        return f"{row_letter}{self.col + 1}"
```

### Warehouse
```python
class Warehouse:
    def __init__(self, rows, cols):
        # Validate input parameters
        if not isinstance(rows, int) or rows <= 0:
            raise ValueError("Rows must be a positive integer")
        if not isinstance(cols, int) or cols <= 0:
            raise ValueError("Columns must be a positive integer")
        
        # Set attributes
        self.rows = rows
        self.cols = cols
        
        # Initialize grid with Location objects
        self.grid = []
        for r in range(rows):
            row = []
            for c in range(cols):
                # Default capacity of 100 for each location
                row.append(Location(r, c, 100))
            self.grid.append(row)
        
        # Dictionary to track all products in the warehouse
        self.products = {}
    
    def add_product(self, product):
        # Validate product
        if not isinstance(product, Product):
            raise ValueError("Must provide a valid Product object")
        
        # Check if SKU already exists
        if product.sku in self.products:
            raise ValueError(f"Product with SKU {product.sku} already exists")
        
        # Add product to warehouse
        self.products[product.sku] = product
        return True
    
    def store_product(self, sku, qty, row, col):
        # Validate input parameters
        if sku not in self.products:
            raise ValueError(f"Product with SKU {sku} not found in warehouse")
        if not isinstance(qty, int) or qty <= 0:
            raise ValueError("Quantity must be a positive integer")
        if not 0 <= row < self.rows:
            raise ValueError(f"Row must be between 0 and {self.rows-1}")
        if not 0 <= col < self.cols:
            raise ValueError(f"Column must be between 0 and {self.cols-1}")
        
        # Get location and add product
        location = self.grid[row][col]
        location.add_product(sku, qty)
        
        # Update product quantity
        self.products[sku].update_quantity(qty)
        return True
    
    def retrieve_product(self, sku, qty, row, col):
        # Validate input parameters
        if sku not in self.products:
            raise ValueError(f"Product with SKU {sku} not found in warehouse")
        if not isinstance(qty, int) or qty <= 0:
            raise ValueError("Quantity must be a positive integer")
        if not 0 <= row < self.rows:
            raise ValueError(f"Row must be between 0 and {self.rows-1}")
        if not 0 <= col < self.cols:
            raise ValueError(f"Column must be between 0 and {self.cols-1}")
        
        # Get location and remove product
        location = self.grid[row][col]
        location.remove_product(sku, qty)
        
        # Update product quantity
        self.products[sku].update_quantity(-qty)
        return True
    
    def find_product(self, sku):
        # Validate input parameters
        if not isinstance(sku, str) or len(sku) == 0:
            raise ValueError("SKU must be a non-empty string")
        
        # Find all locations containing the product
        locations = []
        for r in range(self.rows):
            for c in range(self.cols):
                location = self.grid[r][c]
                if sku in location.inventory:
                    locations.append({
                        "row": r,
                        "col": c,
                        "quantity": location.inventory[sku],
                        "location_code": location.get_location_code()
                    })
        
        return locations
    
    def validate_quantities(self):
        # Check if the sum of quantities across all locations matches the product quantity
        errors = []
        for sku, product in self.products.items():
            total_quantity = 0
            for r in range(self.rows):
                for c in range(self.cols):
                    location = self.grid[r][c]
                    if sku in location.inventory:
                        total_quantity += location.inventory[sku]
            
            if total_quantity != product.quantity:
                errors.append({
                    "sku": sku,
                    "expected": product.quantity,
                    "actual": total_quantity
                })
        
        return errors
    
    def load_data(self):
        # Load products and location data from files
        try:
            # Load products
            with open("products.csv", "r") as file:
                # Skip header line
                next(file)
                for line in file:
                    name, sku, price, quantity = line.strip().split(",")
                    product = Product(name, sku, float(price), int(quantity))
                    self.products[sku] = product
            
            # Load locations
            with open("locations.csv", "r") as file:
                # Skip header line
                next(file)
                for line in file:
                    sku, row, col, quantity = line.strip().split(",")
                    row, col, quantity = int(row), int(col), int(quantity)
                    self.grid[row][col].add_product(sku, quantity)
            
            return True
        except Exception as e:
            print(f"Error loading data: {e}")
            return False
    
    def save_data(self):
        # Save products and location data to files
        try:
            # Save products
            with open("products.csv", "w") as file:
                file.write("name,sku,price,quantity\n")
                for sku, product in self.products.items():
                    file.write(f"{product.name},{sku},{product.price},{product.quantity}\n")
            
            # Save locations
            with open("locations.csv", "w") as file:
                file.write("sku,row,col,quantity\n")
                for r in range(self.rows):
                    for c in range(self.cols):
                        location = self.grid[r][c]
                        for sku, qty in location.inventory.items():
                            file.write(f"{sku},{r},{c},{qty}\n")
            
            return True
        except Exception as e:
            print(f"Error saving data: {e}")
            return False
```

### Mainline
```python
def main():
    # Initialize the warehouse system
    user = input("Enter username: ")
    print(f"Welcome, {user}, to the Warehouse Management System!")
    
    # Create warehouse with 5 rows and 8 columns
    warehouse = Warehouse(rows=5, cols=8)
    
    # Load existing data
    success = warehouse.load_data()
    if not success:
        print("Warning: Could not load existing data. Starting with empty warehouse.")
    
    # Main program loop
    while True:
        print("\nMain Menu:")
        print("1. Add new product")
        print("2. Store product at location")
        print("3. Retrieve product from location")
        print("4. Find product locations")
        print("5. Update product price")
        print("6. Validate inventory")
        print("7. Save data")
        print("8. Exit")
        
        choice = input("Enter your choice (1-8): ")
        
        if choice == "1":
            # Add new product
            name = input("Enter product name: ")
            sku = input("Enter product SKU: ")
            price = float(input("Enter product price: "))
            quantity = 0  # New products start with 0 quantity
            
            try:
                product = Product(name, sku, price, quantity)
                warehouse.add_product(product)
                print(f"Product {name} added successfully!")
            except ValueError as e:
                print(f"Error: {e}")
        
        elif choice == "2":
            # Store product
            sku = input("Enter product SKU: ")
            try:
                qty = int(input("Enter quantity to store: "))
                row = int(input("Enter row number (0-4): "))
                col = int(input("Enter column number (0-7): "))
                
                warehouse.store_product(sku, qty, row, col)
                print(f"Successfully stored {qty} units of {sku} at location {warehouse.grid[row][col].get_location_code()}")
            except ValueError as e:
                print(f"Error: {e}")
        
        elif choice == "3":
            # Retrieve product
            sku = input("Enter product SKU: ")
            try:
                qty = int(input("Enter quantity to retrieve: "))
                row = int(input("Enter row number (0-4): "))
                col = int(input("Enter column number (0-7): "))
                
                warehouse.retrieve_product(sku, qty, row, col)
                print(f"Successfully retrieved {qty} units of {sku} from location {warehouse.grid[row][col].get_location_code()}")
            except ValueError as e:
                print(f"Error: {e}")
        
        elif choice == "4":
            # Find product
            sku = input("Enter product SKU: ")
            locations = warehouse.find_product(sku)
            
            if not locations:
                print(f"Product {sku} not found in any location.")
            else:
                print(f"Product {sku} found in the following locations:")
                for loc in locations:
                    print(f"  {loc['location_code']}: {loc['quantity']} units")
        
        elif choice == "5":
            # Update price
            sku = input("Enter product SKU: ")
            if sku in warehouse.products:
                try:
                    new_price = float(input("Enter new price: "))
                    warehouse.products[sku].update_price(new_price)
                    print(f"Price updated successfully for {sku}!")
                except ValueError as e:
                    print(f"Error: {e}")
            else:
                print(f"Product with SKU {sku} not found.")
        
        elif choice == "6":
            # Validate inventory
            errors = warehouse.validate_quantities()
            if not errors:
                print("Inventory validation successful! All quantities match.")
            else:
                print("Inventory discrepancies found:")
                for error in errors:
                    print(f"  SKU {error['sku']}: Expected {error['expected']}, but found {error['actual']}")
        
        elif choice == "7":
            # Save data
            success = warehouse.save_data()
            if success:
                print("Data saved successfully!")
            else:
                print("Error saving data.")
        
        elif choice == "8":
            # Exit
            print(f"Thank you for using the Warehouse Management System, {user}!")
            break
        
        else:
            print("Invalid choice. Please enter a number between 1 and 8.")

# Run the main function
if __name__ == "__main__":
    main()
```

## Version Control Planning

I used Git for version control. I kept my main branch stable, and did all my new features and bug fixes in separate branches. I tried to write clear commit messages so I could track what I changed and why. I also pushed to GitHub regularly so I wouldn’t lose my work.

## Exception Handling and Validation (Pseudocode)

```
try:
    price = float(input("Enter price: "))
    if price < 0:
        raise ValueError("Price must be non-negative")
except ValueError as e:
    print(f"Input error: {e}")
```

## Algorithm Design and Testing

### Validation
- I made sure to check all user inputs for type, range, and business rules (like unique SKUs and positive quantities).
- When loading data from files, I checked for missing or invalid entries.

### Testing Plan
- I wrote unit tests for the main class methods (add, store, retrieve, validation).
- I tested workflows like adding a product, storing it, and retrieving it, both in the GUI and CLI.
- I used the provided test data to make sure everything worked as expected.
- I also did manual testing, trying out edge cases and intentionally entering bad data to see if the system handled it.

### Writing for Maintenance
- I added docstrings to all my classes and methods, and wrote a README with instructions.
- I followed PEP8 style and used meaningful names for everything.
- The code is modular, so if I want to add new features or fix bugs later, I can do it without breaking the rest of the system.
- I left comments explaining tricky parts or important design decisions.
